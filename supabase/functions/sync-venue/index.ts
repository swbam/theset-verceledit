/// <reference types="https://esm.sh/@supabase/functions-js/src/edge-runtime.d.ts" />

import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
import { corsHeaders } from '../_shared/cors.ts'

// Define expected request body structure
interface SyncVenuePayload {
  venueId: string; // This is the Ticketmaster Venue ID (external_id)
  // Add other options if needed, e.g., force sync
  // force?: boolean;
}

// Define the structure of your Venue data (align with DB schema and types)
// Ensure this matches your 'venues' table exactly
interface Venue {
  id?: string; // Primary Key (UUID), generated by DB or fetched if exists
  external_id: string; // Ticketmaster Venue ID
  name: string;
  city?: string | null;
  state?: string | null;
  country?: string | null;
  address?: string | null;
  latitude?: number | null;
  longitude?: number | null;
  url?: string | null;
  image_url?: string | null;
  created_at?: string;
  updated_at?: string;
  // Add any other relevant fields from your 'venues' table
}

// Helper to get the best image (copied from previous functions)
function getBestImage(images?: Array<{url: string, width: number, height: number}>): string | null {
  if (!images || images.length === 0) return null;
  const sorted = [...images].sort((a, b) => (b.width || 0) - (a.width || 0));
  return sorted[0].url;
}

/**
 * Fetch venue data primarily from Ticketmaster
 */
async function fetchAndTransformVenueData(supabaseAdmin: any, venueExternalId: string): Promise<Venue | null> {
  console.log(`Fetching data for venue with external_id ${venueExternalId}`);
  let venue: Venue | null = null;

  // --- Get Existing Venue Data (using external_id) ---
  try {
    const { data: existingVenue, error: existingError } = await supabaseAdmin
      .from('venues')
      .select('*') // Select all fields to preserve them, especially the UUID 'id'
      .eq('external_id', venueExternalId)
      .maybeSingle();

    if (existingError) {
      console.warn(`Error fetching existing venue ${venueExternalId}:`, existingError.message);
    }
    if (existingVenue) {
      console.log(`Found existing data for venue ${venueExternalId}`);
      venue = existingVenue as Venue;
    }
  } catch (e) {
     const errorMsg = e instanceof Error ? e.message : String(e);
     console.warn(`Exception fetching existing venue ${venueExternalId}:`, errorMsg);
  }

  // --- Ticketmaster API ---
  const tmApiKey = Deno.env.get('TICKETMASTER_API_KEY');
  if (!tmApiKey) {
    console.error('TICKETMASTER_API_KEY not set in environment variables.');
    if (!venue) return null; // Cannot fetch new data if key is missing and no existing data
  } else {
    try {
      const tmUrl = `https://app.ticketmaster.com/discovery/v2/venues/${venueExternalId}.json?apikey=${tmApiKey}`;
      console.log(`Fetching from Ticketmaster: ${tmUrl}`);
      const tmResponse = await fetch(tmUrl);

      if (!tmResponse.ok) {
        console.warn(`Ticketmaster API error for venue ${venueExternalId}: ${tmResponse.status} ${await tmResponse.text()}`);
        if (!venue) return null;
      } else {
        const tmData = await tmResponse.json();
        console.log(`Received Ticketmaster data for venue ${venueExternalId}`);

        const address = [
          tmData.address?.line1,
          tmData.city?.name
        ].filter(Boolean).join(', ');

        // Merge with existing or create new venue object
        if (venue) {
          // Update existing venue
          venue.name = tmData.name;
          venue.city = tmData.city?.name || venue.city || null;
          venue.state = tmData.state?.stateCode || venue.state || null;
          venue.country = tmData.country?.countryCode || venue.country || null;
          venue.address = address || venue.address || null;
          // Ensure latitude/longitude are numbers or null
          venue.latitude = typeof tmData.location?.latitude === 'string' ? parseFloat(tmData.location.latitude) : (tmData.location?.latitude ?? venue.latitude ?? null);
          venue.longitude = typeof tmData.location?.longitude === 'string' ? parseFloat(tmData.location.longitude) : (tmData.location?.longitude ?? venue.longitude ?? null);
          venue.url = tmData.url || venue.url || null;
          venue.image_url = getBestImage(tmData.images) || venue.image_url || null;
          venue.updated_at = new Date().toISOString();
        } else {
          // Create new venue structure from TM data
          venue = {
            external_id: venueExternalId, // Set the external ID
            name: tmData.name,
            city: tmData.city?.name || null,
            state: tmData.state?.stateCode || null,
            country: tmData.country?.countryCode || null,
            address: address || null,
            latitude: typeof tmData.location?.latitude === 'string' ? parseFloat(tmData.location.latitude) : (tmData.location?.latitude ?? null),
            longitude: typeof tmData.location?.longitude === 'string' ? parseFloat(tmData.location.longitude) : (tmData.location?.longitude ?? null),
            url: tmData.url || null,
            image_url: getBestImage(tmData.images) || null,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
            // id will be generated by DB on insert
          };
        }
      }
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error(`Error fetching or processing Ticketmaster data for venue ${venueExternalId}:`, errorMsg);
      if (!venue) return null;
    }
  }

  if (!venue?.name) {
     console.error(`Failed to resolve venue name for external_id ${venueExternalId} from any source.`);
     return null; // Cannot proceed without a name
  }

  return venue;
}


serve(async (req: Request) => {
  // Handle CORS preflight request
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const payload: SyncVenuePayload = await req.json();
    // Rename for clarity within the function scope
    const venueExternalId = payload.venueId;

    if (!venueExternalId) {
      return new Response(JSON.stringify({ error: 'Missing venueId (external_id) in request body' }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      })
    }

    console.log(`Sync request received for venue: ${venueExternalId}`);

    // Initialize Supabase client with SERVICE_ROLE key
    const supabaseAdmin = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    // Fetch and transform data
    const venueData = await fetchAndTransformVenueData(supabaseAdmin, venueExternalId);

    if (!venueData) {
      console.error(`Failed to fetch or transform data for venue ${venueExternalId}`);
      return new Response(JSON.stringify({ error: 'Failed to fetch venue data from external APIs' }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      })
    }

    // Upsert data into Supabase using external_id as conflict target
    console.log(`Upserting venue ${venueExternalId} into database...`);
    // Remove the UUID 'id' before upserting if it exists, let DB handle it or update based on conflict
    const { id: venueUUID, ...upsertData } = venueData;

    const { data: upsertedData, error: upsertError } = await supabaseAdmin
      .from('venues') // Ensure 'venues' is your table name
      .upsert(upsertData, {
         onConflict: 'external_id', // Use the Ticketmaster ID column
         ignoreDuplicates: false // Ensure updates happen
       })
      .select() // Return the upserted record (including the UUID 'id')
      .single();

    if (upsertError) {
      console.error('Supabase upsert error:', upsertError);
      return new Response(JSON.stringify({ error: 'Database error during upsert', details: upsertError.message }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      })
    }

    console.log(`Successfully synced venue ${venueExternalId}`);
    // TODO: Optionally trigger sync for related shows?

    return new Response(JSON.stringify({ success: true, data: upsertedData }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    })
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
    console.error('Unhandled error:', errorMessage, error);
    return new Response(JSON.stringify({ error: errorMessage }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 500,
    })
  }
})